#include <iostream>
using namespace std;

#define mod 1000000000

int main(){
    int n;
    cin >> n;

    //N은 길이로 100까지이고, 계단 수는 0~9까지의 수밖에 없다 그렇기에 10
    int dp[101][10] = {};

    //초기식들
    dp[1][0] = 0; //0은 처음으로 올 수 없기 때문에 1을 선언
    //1로 시작하는 배열은 모두 1의 값을 갖는다. 2부터 값이 달라진다.
    for(int i =1; i<10; i++){
        dp[1][i] = 1;
    }

    //본 계산
    for(int i=2; i<= n; i++){
        //이 경우의 식은 세가지가 있는데 끝나는 수 즉 j가 0 또는 9일때와 이 경우를 제외한 경우들이다.
        //dp[n][b] : n 번째 자리에 b가 왔을 때의 가능한 계단 수의 개수라고 전제를 둔 뒤 문제를 푼다.
        for(int j = 0; j <10; j++){
            if(j==0){
                dp[i][0] = dp[i-1][1]; //j+1로 해도 되지만 걍 알아보기 편하게 1 1로 하는 이유는 0 다음은 1이다.
            }
            else if(j ==9){
                dp[i][9] = dp[i-1][8]; //j-1로 해도 되지만 걍 알아보기 편하게 8로 8로 하는 이유는 9는 8밖에 없으니까
            }
            else{ //만약 2의 경우 1과 3이 붙는 것이 가능하다. dp[3][3] = dp[2][2] + dp[2][4] 를 점화식으로 푼것
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1];
            }

            dp[i][j] %= mod; //첫번째 줄의 정답을 이 수로 나눈 나머지를 출력하라고 조건을 줬기 때문에.
        }
    }

    int result = 0; //결과를 출력할 변수
    for(int i =0; i<10; i++){
        result = (result + dp[n][i]) % mod; //n번째 계단의 수를 모두 구해서 더하기
    }
    cout << result;
    return 0;

}
